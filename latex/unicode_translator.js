// Generated by CoffeeScript 1.10.0
var LaTeX;

if (!LaTeX) {
  LaTeX = {};
}

LaTeX.text2latex = function(text, options) {
  if (options == null) {
    options = {};
  }
  options.mode || (options.mode = 'text');
  return this.html2latex(text, options);
};

LaTeX.html2latex = function(html, options) {
  var latex;
  options.mode || (options.mode = 'html');
  latex = (new this.HTML(html, options)).latex;
  latex = latex.replace(/(\\\\)+\s*\n\n/g, "\n\n");
  latex = latex.replace(/\n\n\n+/g, "\n\n");
  latex = latex.replace(/{}([}])/g, '$1');
  return latex;
};

LaTeX.HTML = (function() {
  function HTML(html, options) {
    if (options == null) {
      options = {};
    }
    this.latex = '';
    this.mapping = (Translator.unicode ? LaTeX.toLaTeX.unicode : LaTeX.toLaTeX.ascii);
    this.stack = [];
    this.walk(Translator.MarkupParser.parse(html, options));
  }

  HTML.prototype.walk = function(tag) {
    var child, i, len, postfix, ref, ref1;
    if (!tag) {
      return;
    }
    switch (tag.name) {
      case '#text':
        this.chars(tag.text);
        return;
      case 'pre':
        this.latex += tag.text;
        return;
    }
    this.stack.unshift(tag);
    if (tag.smallcaps) {
      this.latex += '\\textsc{';
    }
    if (tag.nocase) {
      this.latex += '{{';
    }
    if (tag.relax) {
      this.latex += '{\\relax ';
    }
    postfix = '';
    switch (tag.name) {
      case 'i':
      case 'em':
      case 'italic':
        this.latex += '{\\emph{';
        postfix = '}}';
        break;
      case 'b':
      case 'strong':
        this.latex += '{\\textbf{';
        postfix = '}}';
        break;
      case 'a':

        /* zotero://open-pdf/0_5P2KA4XM/7 is actually a reference. */
        if (((ref = tag.attrs.href) != null ? ref.length : void 0) > 0) {
          this.latex += "\\href{" + tag.attrs.href + "}{";
          postfix = '}';
        }
        break;
      case 'sup':
        this.latex += '{\\textsuperscript{';
        postfix = '}}';
        break;
      case 'sub':
        this.latex += '{\\textsubscript{';
        postfix = '}}';
        break;
      case 'br':

        /* line-breaks on empty line makes LaTeX sad */
        if (this.latex !== '' && this.latex[this.latex.length - 1] !== "\n") {
          this.latex += "\\\\";
        }
        this.latex += "\n";
        break;
      case 'p':
      case 'div':
      case 'table':
      case 'tr':
        this.latex += "\n\n";
        postfix = "\n\n";
        break;
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
        this.latex += "\n\n\\" + ((new Array(parseInt(tag.name[1]))).join('sub')) + "section{";
        postfix = "}\n\n";
        break;
      case 'ol':
        this.latex += "\n\n\\begin{enumerate}\n";
        postfix = "\n\n\\end{enumerate}\n";
        break;
      case 'ul':
        this.latex += "\n\n\\begin{itemize}\n";
        postfix = "\n\n\\end{itemize}\n";
        break;
      case 'li':
        this.latex += "\n\\item ";
        break;
      case 'enquote':
        this.latex += '\\enquote{';
        postfix = '}';
        break;
      case 'span':
      case 'sc':
      case 'nc':
        break;
      case 'td':
      case 'th':
        this.latex += ' ';
        postfix = ' ';
        break;
      case 'tbody':
      case '#document':
      case 'html':
      case 'head':
      case 'body':
        break;
      default:
        Translator.debug("unexpected tag '" + tag.name + "' (" + (Object.keys(tag)) + ")");
    }
    ref1 = tag.children;
    for (i = 0, len = ref1.length; i < len; i++) {
      child = ref1[i];
      this.walk(child);
    }
    this.latex += postfix;
    if (tag.relax) {
      this.latex += '}';
    }
    if (tag.nocase) {
      this.latex += '}}';
    }
    if (tag.smallcaps) {
      this.latex += '}';
    }
    return this.stack.shift();
  };

  HTML.prototype.chars = function(text) {
    var braced, c, i, latex, len, math, ref;
    latex = '';
    math = false;
    braced = 0;
    ref = XRegExp.split(text, '');
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      if (!!this.mapping.math[c] !== math) {
        latex += '$';
        math = !!this.mapping.math[c];
      }

      /* balance out braces with invisible braces until http://tex.stackexchange.com/questions/230750/open-brace-in-bibtex-fields/230754#comment545453_230754 is widely deployed */
      switch (c) {
        case '{':
          braced += 1;
          break;
        case '}':
          braced -= 1;
      }
      if (braced < 0) {
        latex += "\\vphantom\\{";
        braced = 0;
      }
      latex += this.mapping.math[c] || this.mapping.text[c] || c;
    }
    switch (braced) {
      case 0:
        break;
      case 1:
        latex += "\\vphantom\\}";
        break;
      default:
        latex += "\\vphantom{" + ((new Array(braced + 1)).join("\\}")) + "}";
    }
    if (math) {
      latex += "$";
    }

    /* minor cleanup */
    latex = latex.replace(/({})+([^0-9a-z])/ig, '$2');
    return this.latex += latex;
  };

  return HTML;

})();
