// Generated by CoffeeScript 1.10.0
var LaTeX;

if (!LaTeX) {
  LaTeX = {};
}

LaTeX.text2latex = function(text, options) {
  if (options == null) {
    options = {};
  }
  options.mode || (options.mode = 'text');
  return this.html2latex(text, options);
};

LaTeX.html2latex = function(html, options) {
  var latex;
  options.mode || (options.mode = 'html');
  latex = (new this.HTML(html, options)).latex;
  latex = latex.replace(/(\\\\)+\s*\n\n/g, "\n\n");
  latex = latex.replace(/\n\n\n+/g, "\n\n");
  latex = latex.replace(/{}([}])/g, '$1');
  return latex;
};

LaTeX.HTML = (function() {
  function HTML(html, options1) {
    this.options = options1 != null ? options1 : {};
    this.latex = '';
    this.mapping = (Translator.unicode ? LaTeX.toLaTeX.unicode : LaTeX.toLaTeX.ascii);
    this.stack = [];
    this.walk(Translator.MarkupParser.parse(html, this.options));
  }

  HTML.prototype.walk = function(tag) {
    var child, i, latex, len, postfix, prefix, ref, ref1, ref2;
    if (!tag) {
      return;
    }
    switch (tag.name) {
      case '#text':
        this.chars(tag.text);
        return;
      case 'pre':
        this.latex += tag.text;
        return;
    }
    this.stack.unshift(tag);
    latex = '...';
    switch (tag.name) {
      case 'i':
      case 'em':
      case 'italic':
        latex = '\\emph{...}';
        break;
      case 'b':
      case 'strong':
        latex = '\\textbf{...}';
        break;
      case 'a':

        /* zotero://open-pdf/0_5P2KA4XM/7 is actually a reference. */
        if (((ref = tag.attrs.href) != null ? ref.length : void 0) > 0) {
          latex = "\\href{" + tag.attrs.href + "}{...}";
        }
        break;
      case 'sup':
        latex = '\\textsuperscript{...}';
        break;
      case 'sub':
        latex = '\\textsubscript{...}';
        break;
      case 'br':
        latex = '';

        /* line-breaks on empty line makes LaTeX sad */
        if (this.latex !== '' && this.latex[this.latex.length - 1] !== "\n") {
          latex = "\\\\";
        }
        latex += "\n...";
        break;
      case 'p':
      case 'div':
      case 'table':
      case 'tr':
        latex = "\n\n...\n\n";
        break;
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
        latex = "\n\n\\" + ((new Array(parseInt(tag.name[1]))).join('sub')) + "section{...}\n\n";
        break;
      case 'ol':
        latex = "\n\n\\begin{enumerate}\n...\n\n\\end{enumerate}\n";
        break;
      case 'ul':
        latex = "\n\n\\begin{itemize}\n...\n\n\\end{itemize}\n";
        break;
      case 'li':
        latex = "\n\\item ...";
        break;
      case 'enquote':
        latex = '\\enquote{...}';
        break;
      case 'span':
      case 'sc':
      case 'nc':
        break;
      case 'td':
      case 'th':
        latex = ' ... ';
        break;
      case 'tbody':
      case '#document':
      case 'html':
      case 'head':
      case 'body':
        break;
      default:
        Translator.debug("unexpected tag '" + tag.name + "' (" + (Object.keys(tag)) + ")");
    }

    /* holy mother of %^$#^%$@ the bib(la)tex case conversion rules are insane */

    /* https://github.com/retorquere/zotero-better-bibtex/issues/541 */

    /* https://github.com/plk/biblatex/issues/459 ... oy! */
    if (this.embrace == null) {
      this.embrace = this.options.caseConversion && ((this.latex || latex)[0] !== '\\');
    }
    if (this.embrace && latex.match(/^\\[a-z]+{\.\.\.}$/)) {
      latex = '{' + latex + '}';
    }
    if (tag.smallcaps) {
      latex = "\\textsc{" + latex + "}";
    }
    if (this.embrace && tag.smallcaps) {
      latex = '{' + latex + '}';
    }
    if (tag.nocase) {
      latex = "{{" + latex + "}}";
    }
    if (tag.relax) {
      latex = "{\\relax " + latex + "}";
    }
    ref1 = latex.split('...'), prefix = ref1[0], postfix = ref1[1];
    this.latex += prefix;
    ref2 = tag.children;
    for (i = 0, len = ref2.length; i < len; i++) {
      child = ref2[i];
      this.walk(child);
    }
    this.latex += postfix;
    return this.stack.shift();
  };

  HTML.prototype.chars = function(text) {
    var braced, c, i, latex, len, math, ref;
    latex = '';
    math = false;
    braced = 0;
    ref = XRegExp.split(text, '');
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      if (!!this.mapping.math[c] !== math) {
        latex += '$';
        math = !!this.mapping.math[c];
      }

      /* balance out braces with invisible braces until http://tex.stackexchange.com/questions/230750/open-brace-in-bibtex-fields/230754#comment545453_230754 is widely deployed */
      switch (c) {
        case '{':
          braced += 1;
          break;
        case '}':
          braced -= 1;
      }
      if (braced < 0) {
        latex += "\\vphantom\\{";
        braced = 0;
      }
      latex += this.mapping.math[c] || this.mapping.text[c] || c;
    }
    switch (braced) {
      case 0:
        break;
      case 1:
        latex += "\\vphantom\\}";
        break;
      default:
        latex += "\\vphantom{" + ((new Array(braced + 1)).join("\\}")) + "}";
    }
    if (math) {
      latex += "$";
    }

    /* minor cleanup */
    latex = latex.replace(/([^\\])({})+([^0-9a-z])/ig, '$1$3');
    return this.latex += latex;
  };

  return HTML;

})();
