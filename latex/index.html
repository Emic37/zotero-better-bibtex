<html>
  <head>
    <title>BibTeX Translator</title>
    <script>
      var Translator = { unicode: true, debug: function(msg) { console.log(msg); }}, LaTeX = {};
    </script>
    <script src="franc-most.js"></script>
    <script src="xregexp-all.js"></script>
    <script src="titlecaser.js"></script>
    <script src="simple-titlecaser.js"></script>
    <script src="markupparser.js"></script>
    <script src="latex_unicode_mapping.js"></script>
    <script src="unicode_translator.js"></script>

    <script>
      var Options = {
        titles: '',
        unicode: true,
        titlecaser: {citeproc: 'CiteProc-js', simple: 'Simple'},
        language: {'guess': 'Guess based on input', 'eng': 'Assume English', 'und': 'Assume other'},
        translator: {'biblatex': 'BibLaTeX', 'bibtex': 'BibTeX'}
      };

      var Reconstruct = (function() {
        function Reconstruct(ast) {
          this.html = '';
          this.walk(ast);
        }

        Reconstruct.prototype.walk = function(node) {
          var child, i, j, k, len, len1, ref, ref1, ref2, results, v;
          switch (false) {
            case node.name !== '#text':
              return this.html += node.text;
            case !(node.name === 'span' && Object.keys(node.attr).length === 0):
              ref = node.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                results.push(this.walk(child));
              }
              return results;
              break;
            default:
              this.html += "<" + node.name;
              ref1 = node.attr;
              for (k in ref1) {
                v = ref1[k];
                this.html += " " + k + "='" + v + "'";
              }
              this.html += '>';
              ref2 = node.children;
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                child = ref2[j];
                this.walk(child);
              }
              return this.html += "</" + node.name + ">";
          }
        };
      
        return Reconstruct;
      
      })();

      var TitleCaser = {
        citeproc: Translator.TitleCaser.titleCase.bind(Translator.TitleCaser),
        simple: Translator.simpleTitleCaser.titleCase.bind(Translator.simpleTitleCaser)
      };

      function parse() {
        var options = {};
        var query = [];

        for (var key in Options) {
          var value = Options[key];
          switch (Object.prototype.toString.call(value)) {
            //case '[object Array]':
            case '[object Object]':
              var values = Object.keys(value)
              options[key] = values[0];
              values.forEach(function (option) { if (document.getElementById(option).checked) { options[key] = option; }});
              query.push(key + '=' + encodeURIComponent(options[key]));
              break;

            case '[object String]':
              options[key] = document.getElementById(key).value;
              query.push(key + '=' + encodeURIComponent(options[key]));
              break;

            case '[object Boolean]':
              options[key] = !!document.getElementById(key).checked;
              query.push(key + '=' + encodeURIComponent(!!options[key]));
              break;

            default:
              throw new Error('Unexpected option ' + key + ' of type ' + Object.prototype.toString.call(value))
          }
        }

        if (!options.titles.trim()) { return; }

        if (window.location.protocol != 'file:') {
          window.history.pushState(null, null, 'index.html?' + query.join('&'));
        }

        Translator.unicode = options.unicode;

        if (options.titlecaser == 'simple') {
          Translator.TitleCaser.titleCase = TitleCaser.simple;
        } else {
          Translator.TitleCaser.titleCase = TitleCaser.citeproc;
        }

        Translator.BetterBibTeX = (options.translator == 'bibtex');
        Translator.BetterBibLaTeX = (options.translator == 'biblatex');

        var output = document.getElementById('output');
        var bibtex;
        output.textContent = '';

        options.titles.split("\n").forEach(function(title) {
          if (!title.trim()) { return; }

          var language = (options.language == 'guess' ? franc(innerText(title)) : options.language || 'und');
          var english = (language == 'eng' || language == 'sco');
          bibtex = '{' + LaTeX.text2latex(title, {caseConversion: english}) + '}';
          if (Translator.BetterBibTeX && !english) { bibtex = '{' + bibtex + '}'; }

          output.textContent += [
            language + ': ' + title,
            'titlecased: ' + Translator.TitleCaser.titleCase(title),
            'reconstructed: ' + (new Reconstruct(Translator.MarkupParser.parse(title, {caseConversion: english}))).html,
            options.translator + ': ' + bibtex
          ].join("\n") + "\n";

          (new Reconstruct(ast)).html
        });
        return false;
      }

      function innerText(text) {
        var div = document.getElementById('innertext');
        div.innerHTML = text;
        return div.innerText;
      }
    </script>
  </head>
  <body>
    <div id="innertext" style="display: none"></div>
    <form id="form", name="form" onsubmit="return parse();">
    </form>
    <script>
      var textTimeOut = null;

      function delayedParse() {
        if (textTimeOut) { window.clearTimeout(textTimeOut); }
        textTimeOut = window.setTimeout(function() { textTimeOut = null; parse(); }, 500);
      }

      var form = '<table border="0">';

      for (var key in Options) {
        var value = Options[key];

        form += '<tr><td align="left" valign="top">' + key + ': ' + '</td><td>'

        switch (Object.prototype.toString.call(value)) {
          case '[object Object]':
            for (var option in value) {
              var label = value[option];
              form += '<input onclick="parse();" id="' + option + '" type="radio" name="' + key + '" value="' + option + '"> ' + label + '&nbsp;&nbsp;';
            }
            break;

          case '[object String]':
            form += '<textarea oninput="delayedParse();" id="' + key + '" rows="10" cols="120"></textarea>'
            break;

          case '[object Boolean]':
            form += '<input onclick="parse();" id="' + key + '" name="' + key + '" value="' + key + '" type="checkbox">';
            break;

          default:
            throw new Error('Unexpected option ' + key + ' of type ' + Object.prototype.toString.call(value))
        }

        form += "</td></tr>\n";
      }
      form += '</table>';
      // form += '<input type="submit" vaue="Translate">';

      document.getElementById('form').innerHTML = form;
    </script>
    </form>
    <pre id="output"></pre>
  </body>

  <script>
    function decode(str) {
      if (!str) { return str; }
      return decodeURIComponent(str.replace(/\+/g, ' '));
    }

    var QueryString = function () {
      // This function is anonymous, is executed immediately and 
      // the return value is assigned to QueryString!
      var query_string = {};
      var query = window.location.search.substring(1);
      var vars = query.split("&");
      for (var i=0;i<vars.length;i++) {
        var pair = vars[i].split("=");
            // If first entry with this name
        if (typeof query_string[pair[0]] === "undefined") {
          query_string[pair[0]] = decode(pair[1]);
            // If second entry with this name
        } else if (typeof query_string[pair[0]] === "string") {
          var arr = [ query_string[pair[0]],decode(pair[1]) ];
          query_string[pair[0]] = arr;
            // If third or later entry with this name
        } else {
          query_string[pair[0]].push(decode(pair[1]));
        }
      } 
        return query_string;
    }();

    for (var key in Options) {
      var value = Options[key];
      switch (Object.prototype.toString.call(value)) {
        case '[object Object]':
          var values = Object.keys(value);
          document.getElementById(values[0]).checked = true;
          values.forEach(function (option) { if (QueryString[key] == option) { document.getElementById(option).checked = true; } });
          break;

        case '[object String]':
          if (QueryString[key]) {
            document.getElementById(key).value = (QueryString[key] || '');
          } else {
            document.getElementById(key).value = value;
          }
          break;

        case '[object Boolean]':
          if (QueryString[key]) {
            document.getElementById(key).checked = (QueryString[key] == 'true');
          } else {
            document.getElementById(key).checked = value;
          }
          break;
      }
    }

    if (QueryString.titles) { parse(); }
  </script>
</html>
