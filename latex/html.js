// Generated by CoffeeScript 1.10.0
var Reconstruct, display, html;

Translator.csquotes = {
  open: '‹«',
  close: '›»'
};

Translator.unicode = true;

Translator.titleCaseLowerCase = 'about above across afore after against along\nalongside amid amidst among amongst anenst apropos apud around as\naside astride at athwart atop barring before behind below beneath\nbeside besides between beyond but by circa despite down during\nexcept for forenenst from given in inside into lest like modulo\nnear next notwithstanding of off on onto out over per plus pro qua\nsans since than through thru throughout thruout till to toward\ntowards under underneath until unto up upon versus vs. v. vs v via\nvis-à-vis with within without according to ahead of apart from as\nfor as of as per as regards aside from back to because of close to\ndue to except for far from inside of instead of near to next to on\nto out from out of outside of prior to pursuant to rather than\nregardless of such as that of up to where as or yet so and nor a\nan the de d\' von van c et ca thru according ahead apart regards\nback because close due far instead outside prior pursuant rather\nregardless such their where'.replace(/\n/g, ' ').trim().split(/\s+/);

Reconstruct = (function() {
  function Reconstruct(ast) {
    this.html = '';
    this.walk(ast);
  }

  Reconstruct.prototype.walk = function(node) {
    var base, child, i, j, k, len, len1, ref, ref1, ref2, v;
    if (node.name === '#text') {
      this.html += node.text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return;
    }
    for (k in node) {
      if (k !== 'children' && k !== 'name' && k !== 'attr' && k !== 'class') {
        (base = node.attr)[k] || (base[k] = '');
      }
    }
    if (node.name === 'span' && Object.keys(node.attr).length === 0) {
      ref = node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        this.walk(child);
      }
      return;
    }
    this.html += "<" + node.name;
    ref1 = node.attr;
    for (k in ref1) {
      v = ref1[k];
      this.html += " " + k + "='" + v + "'";
    }
    this.html += '>';
    ref2 = node.children;
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      child = ref2[j];
      this.walk(child);
    }
    return this.html += "</" + node.name + ">";
  };

  return Reconstruct;

})();

display = function(html, options) {
  var ast, cp, lang;
  console.log(html);
  ast = Translator.MarkupParser.parse(html, {
    caseConversion: true
  });
  console.log(JSON.stringify(ast, null, 2));
  console.log((new Reconstruct(ast)).html);
  console.log(LaTeX.text2latex(html, {
    caseConversion: true
  }));
  return;
  lang = ((options.language || '<none>') + '        ').substr(0, 8);
  console.log(options.source);
  console.log(lang + ": `" + html + "`");
  console.log(Translator.TitleCaser.titleCase(html));
  options.caseConversion = (options.language || 'en') === 'en';
  cp = LaTeX.text2latex(html, options);
  console.log("biblatex: {" + cp + "}");
  return console.log('');
};

html = 'How to derive<i> "Ought" from "Is"</i>';

display(html, {});
